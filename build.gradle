import com.bmuschko.gradle.docker.tasks.container.DockerCopyFileFromContainer

import de.undercouch.gradle.tasks.download.Download

import groovy.json.JsonSlurper

import java.time.format.DateTimeFormatter

plugins {
	id "com.avast.gradle.docker-compose" version "0.17.10"
}

String[] databasePartitioningCompatibleServiceNames = ["mysql", "postgres"]
File projectDir = project.projectDir as File

class Config {

	public Config(Project project) {
		Integer clusterNodes = project.getProperty("lr.docker.environment.cluster.nodes") as Integer

		if (clusterNodes != null) {
			this.clusterNodes = clusterNodes
		}

		this.composeFiles.add("docker-compose.yaml")

		this.composeFiles.addAll(this.toList(project.getProperty("lr.docker.environment.compose.files")))

		String databaseName = project.getProperty("lr.docker.environment.database.name")

		if (databaseName != null) {
			this.databaseName = databaseName
		}

		String databasePartitioningEnabled = project.getProperty("lr.docker.environment.database.partitioning.enabled")

		if (databasePartitioningEnabled != null) {
			this.databasePartitioningEnabled = databasePartitioningEnabled.toBoolean()
		}

		String dataDirectory = project.getProperty("lr.docker.environment.data.directory")

		if (dataDirectory != null && dataDirectory.length() > 0) {
			this.dataDirectory = dataDirectory
		}

		List hotfixURLs = this.toList(project.getProperty("lr.docker.environment.hotfix.urls"))

		if (!hotfixURLs.isEmpty()) {
			this.hotfixURLs = hotfixURLs
		}

		String namespace = project.getProperty("lr.docker.environment.namespace")

		if (namespace != null) {
			this.namespace = namespace
		}

		List services = project.properties.findAll {
			it.key =~ /^lr.docker.environment.service.enabled\[\w+\]$/
		}.findAll {
			it.value =~ /true|1/
		}.collect {
			it.key.substring(it.key.indexOf("[") + 1, it.key.indexOf("]"))
		}

		if (!services.isEmpty()) {
			this.services = services
		}

		this.liferayDockerImageId = "${this.namespace.toLowerCase()}-liferay"

		def webserverHostnames = project.getProperty("lr.docker.environment.web.server.hostnames").split(',')*.trim().findAll { it }

		if(webserverHostnames != null) {
			this.webserverHostnames = webserverHostnames.join(' ')
		}
	}

	static List toList(String s) {
		return s.trim().split(",").grep()
	}

	public int clusterNodes = 0
	public List<String> composeFiles = new ArrayList<String>()
	public String databaseName = "lportal"
	public boolean databasePartitioningEnabled = false
	public String dataDirectory = "data"
	public List<String> hotfixURLs = new ArrayList<String>()
	public String liferayDockerImageId = ""
	public String namespace = "lrswde"
	public List<String> services = new ArrayList<String>()
	public String webserverHostnames = "my.example.com"

	@Override
	public String toString() {

		return """

Config:
------------------------
clusterNodes: ${clusterNodes}
composeFiles: ${composeFiles}
databaseName: ${databaseName}
databasePartitioningEnabled: ${databasePartitioningEnabled}
dataDirectory: ${dataDirectory}
hotfixURLs: ${hotfixURLs}
liferayDockerImageId: ${liferayDockerImageId}
namespace: ${namespace}
services: ${services}
webserverHostnames: ${webserverHostnames}

"""
	}
}

Config config = new Config(project)

gradle.liferayWorkspace {
	dockerImageId = config.liferayDockerImageId
}

boolean useLiferay = config.services.contains("liferay")

boolean useClustering = useLiferay && config.clusterNodes > 0

boolean useWebserver = config.services.contains("webserver")

ConfigurableFileTree dockerComposeFileTree = project.fileTree(projectDir) {
	include "**/service.*.yaml"

	if (useClustering) {
		include "**/clustering.*.yaml"
	}

	if (useLiferay) {
		include "**/liferay.*.yaml"
	}

	if (config.databasePartitioningEnabled) {
		if (!config.services.any {databasePartitioningCompatibleServiceNames.contains(it)}) {
			throw new GradleException("Database partitioning must be used with one of these databases: ${databasePartitioningCompatibleServiceNames}")
		}

		include "**/database-partitioning.*.yaml"
	}
}

List<String> serviceComposeFiles = config.services.collect {
	String serviceName ->

	FileTree matchingFileTree = dockerComposeFileTree.matching {
		include "**/*.${serviceName}.yaml"
	}

	if (matchingFileTree.isEmpty()) {
		List<String> possibleServices = dockerComposeFileTree.findAll{
			it.name.startsWith("service.")
		}.collect {
			it.name.substring("service.".length(), it.name.indexOf(".yaml"))
		}

		throw new GradleException(
			"The service '${serviceName}' does not have a matching service.*.yaml file. Possible services are: ${possibleServices}");
	}

	matchingFileTree.getFiles()
}.flatten().collect {
	projectDir.relativePath(it)
}

config.composeFiles.addAll(serviceComposeFiles)

tasks.register("exportContainerData", DockerCopyFileFromContainer) {
	containerId = "${config.namespace}-data-helper"

	doFirst {
		mkdir hostPath.get()
	}

	hostPath = provider {
		DateTimeFormatter formatter = DateTimeFormatter.
		ofPattern("yyyyMMdd.HHmmss").
		withZone(ZoneId.systemDefault())

		"exported_data/data_${config.namespace}_${formatter.format(Instant.now())}"
	}

	remotePath = "/data/container-data"
}

tasks.register("prepareHotfixes", Download) {
	dest project.layout.dir(project.provider {project.file("configs/common/patching")})

	onlyIf {
		!config.hotfixURLs.isEmpty()
	}

	src config.hotfixURLs
}

tasks.register("shareWorkspace", Zip) {
	archiveFileName = provider {
		DateTimeFormatter formatter = DateTimeFormatter.
		ofPattern("yyyyMMdd.HHmmss").
		withZone(ZoneId.systemDefault())

		"workspace_${config.namespace}_${formatter.format(Instant.now())}.zip"
	}

	destinationDirectory = file 'shared_workspaces'

	doLast {
		logger.lifecycle "\nWorkspace zip: ${archiveFile.get()}\n"
	}

	exclude ".gitkeep"
	exclude ".gitignore"
	exclude ".git"
	exclude ".gradle"
	exclude "shared_workspaces"
	exclude {
		it.relativePath.pathString.startsWith("exported_data/") &&
		!it.relativePath.pathString.startsWith(config.dataDirectory)
	}

	from '.'

	include "${config.dataDirectory}/**"
	include "**/*"

	outputs.upToDateWhen {
		false
	}
}

tasks.register("start") {
	dependsOn ":composeUp"
}

tasks.register("stop") {
	dependsOn ":composeDown"
}

clean {
	dependsOn ":cleanPrepareHotfixes"
}

dockerDeploy {
	if (useLiferay) {
		dependsOn ":prepareHotfixes"
	}
}

composeUp {
	if (useLiferay) {
		dependsOn ":buildDockerImage"
	}

	doFirst {
		println "Using config: ${config}"
	}

	onlyIf {
		!config.composeFiles.isEmpty()
	}
}

Map<String, String> environmentMap = [:]

environmentMap.put "DATA_DIRECTORY", config.dataDirectory
environmentMap.put "DATABASE_NAME", config.databaseName
environmentMap.put "NAMESPACE", config.namespace

if (useClustering) {
	environmentMap.put "LIFERAY_CLUSTER_NODES", config.clusterNodes
}

if (useLiferay) {
	environmentMap.put "LIFERAY_IMAGE_NAME", config.liferayDockerImageId
}

environmentMap.put("COMPOSE_FILE", config.composeFiles.join(File.pathSeparator))
environmentMap.put("COMPOSE_PROJECT_NAME", config.namespace.toLowerCase())

if(useWebserver) {
	File webserverConfigDir = "compose-recipes/webserver/config" as File
	File webserverDefaultConfig = "$webserverConfigDir/default.conf" as File

	String webserverConfigUpstreamBlock = useClustering ? """upstream appserver-http {
	ip_hash;
	server liferay:8080;
	server liferay-cluster-node:8080;
}
""" : """upstream appserver-http {
	ip_hash;
	server liferay:8080;
}
"""

	String webserverConfig = """proxy_cache_path  /tmp/cache levels=1:2 keys_zone=STATIC:10m inactive=24h max_size=1g;

server {
	listen 80;

	server_name ${config.webserverHostnames};

	location / {
		proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
		proxy_set_header X-Forwarded-Proto \$http_x_forwarded_proto;
		proxy_set_header X-Forwarded-Port \$http_x_forwarded_port;
		proxy_set_header Host \$host;
		proxy_set_header X-Real-IP \$http_x_forwarded_for;
		proxy_set_header Upgrade \$http_upgrade;
		proxy_set_header Connection \$http_connection;
		proxy_buffering on;
		proxy_cache STATIC;
		proxy_cache_valid 200 1d;
		proxy_cache_use_stale  error timeout invalid_header updating http_500 http_502 http_503 http_504;
		proxy_pass http://appserver-\$scheme;
	}

	location /nginx_status {
		stub_status on;
		allow all;
	}
}

${webserverConfigUpstreamBlock}
"""

	webserverDefaultConfig.text = webserverConfig
}

new File('.env').withOutputStream {
	BufferedOutputStream envFileOutputStream ->

	environmentMap.forEach {
		key, value ->

		envFileOutputStream << key << "=" << value << "\n"
	}
}

dockerCompose {
	// DEBUG: Set to true to print container startup output to the console
	captureContainersOutput = false

	// DEBUG: Uncomment to dump the container logs to a directory for inspection
	// captureContainersOutputToFiles = project.file('containerLogs')

	environment.putAll environmentMap

	projectName = config.namespace

	// DEBUG: Set to false to retain volume data on restart
	removeVolumes = true

	tcpPortsToIgnoreWhenWaiting = [8000, 11311]
	useComposeFiles = config.composeFiles

	// DEBUG: Set to true if container startup is failing
	retainContainersOnStartupFailure = true
}