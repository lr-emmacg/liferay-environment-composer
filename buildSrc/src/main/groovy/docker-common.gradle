import com.liferay.docker.workspace.environments.Config
import com.liferay.docker.workspace.environments.Util

import groovy.json.JsonSlurper

ext {
	config = new Config(project)

	addToVolume = {
		String volumeName, File sourceFile ->

		String sourcePath = sourceFile.absolutePath

		if (!sourceFile.exists()) {
			throw new GradleException("Unable to find file ${sourcePath}")
		}

		String targetName = sourceFile.name

		println "Copying file ${sourcePath} to ${volumeName}"
		waitForCommand("docker run --rm -v ${volumeName}:/target -v ${sourcePath}:/source/${targetName} busybox:latest sh -c 'cp --recursive --update /source/. /target/'")

		println waitForCommand("docker run --rm -v ${volumeName}:/target busybox:latest du -sh /target/${targetName}")

		println "Copied file ${sourcePath} to ${volumeName}"
	}

	executeSQLQuery = {
		String sql, String schema = null ->

		if (!config.useDatabase) {
			throw new GradleException("Database service not detected")
		}

		waitForContainer("database", config.dockerContainerDatabase)

		if (config.useDatabaseMariaDB || config.useDatabaseMySQL) {
			List<String> results = waitForCommand("${getDatabaseAccessCommand(schema)} --batch --execute=\"${sql}\"").split("\n")

			return toResultRows(results, /\t/)
		}

		if (config.useDatabasePostgreSQL) {
			if (schema == null || schema.equals(config.databaseName)) {
				schema = "public"
			}

			List<String> results = waitForCommand("${getDatabaseAccessCommand(schema)} --quiet --csv --command=\"${sql}\"").split("\n")

			return toResultRows(results, /,/)
		}

		if (config.useDatabaseDB2) {
			List<String> results = waitForCommand("${getDatabaseAccessCommand(schema)} \"${sql}\"").split("\n").minus("")

			results.removeLast()
			results.remove(1)

			return toResultRows(results, /\s+/)
		}

		throw new GradleException("Unrecognized database type")
	}

	fixProductVersion = {
		String productVersion ->

		return Util.fixReleaseKey(productVersion)
	}

	forEachCompanyId = {
		Closure<Void> action ->

		List<Map<String, String>> companyVirtualHosts = getCompanyVirtualHosts()

		String defaultWebId = getCompanyDefaultWebId(companyVirtualHosts)

		companyVirtualHosts.each {
			Map<String, String> companyVirtualHost ->

			try {
				String schema = config.databaseName

				if (config.databasePartitioningEnabled && !companyVirtualHost["webId"].equals(defaultWebId)) {
					schema = "lpartition_${companyVirtualHost["companyId"]}"
				}

				action(companyVirtualHost["companyId"], companyVirtualHost["hostname"], companyVirtualHost["webId"], schema)
			}
			catch (Exception e) {
				e.printStackTrace()
			}
		}
	}

	getCompanyVirtualHosts = {
		if (!config.useDatabase || (config.companyVirtualHosts != null)) {
			return config.companyVirtualHosts
		}

		config.companyVirtualHosts = executeSQLQuery("select companyId, hostname, webId from VirtualHost inner join Company using (companyId) where layoutSetId = 0", config.databaseName)

		return config.companyVirtualHosts
	}

	getDatabaseAccessCommand = {
		String schema ->

		if (config.useDatabaseMariaDB || config.useDatabaseMySQL) {
			String command = "docker compose exec -it database mysql --user root"

			if (schema != null) {
				command += " --database=${schema}"
			}

			return command
		}

		if (config.useDatabasePostgreSQL) {
			if (schema == null || schema.equals(config.databaseName)) {
				schema = "public"
			}

			return "docker compose exec -e PGPASSWORD=password -e PGOPTIONS=\"--search_path=${schema}\" -it database psql --username=liferay --dbname=${config.databaseName}"
		}

		if (config.useDatabaseDB2) {
			if (schema == null) {
				schema = config.databaseName
			}

			return [
				"docker compose exec --user db2admin -it database /opt/ibm/db2/V11.5/bin/db2 connect to ${schema} > /dev/null",
				"docker compose exec --user db2admin -it database /opt/ibm/db2/V11.5/bin/db2"
			].join("\n")
		}
	}

	getCompanyDefaultWebId = {
		List<Map<String, String>> companyVirtualHosts ->

		if (!config.useDatabase || (config.defaultCompanyVirtualHost != null) || companyVirtualHosts.isEmpty()) {
			return config.defaultCompanyVirtualHost != null ? config.defaultCompanyVirtualHost["webId"] : null
		}

		String propertyWebId = getPortalPropertyValue("company.default.web.id")

		if (propertyWebId == null) {
			propertyWebId = "liferay.com"
		}

		Map<String, String> defaultCompanyVirtualHost = (companyVirtualHosts.size() == 1) ? companyVirtualHosts[0] : null

		if (defaultCompanyVirtualHost == null) {
			defaultCompanyVirtualHost = companyVirtualHosts.find {
				Map<String, String> companyVirtualHost ->

				companyVirtualHost["webId"] == propertyWebId
			}
		}

		if (defaultCompanyVirtualHost == null) {
			defaultCompanyVirtualHost = companyVirtualHosts.find {
				Map<String, String> companyVirtualHost ->

				companyVirtualHost["webId"].startsWith("admin-") && companyVirtualHost["webId"].endsWith(".lxc.liferay.com")
			}

			if (defaultCompanyVirtualHost != null && !config.databasePartitioningEnabled) {
				config.databasePartitioningEnabled = true

				updateGradleLocalProperties(["lr.docker.environment.database.partitioning.enabled": "true"])
			}
		}

		if (defaultCompanyVirtualHost == null) {
			throw new GradleException("Unable to auto-detect company.default.web.id from ${companyVirtualHosts}, please set it in configs/common/portal-ext.properties")
		}

		config.defaultCompanyVirtualHost = defaultCompanyVirtualHost

		return config.defaultCompanyVirtualHost["webId"]
	}

	getExistingVolumeNames = {
		String volumeNameLines = waitForCommand("docker volume ls --filter 'name=${config.namespace}_' --format '{{ .Name }}'")

		return volumeNameLines.isEmpty() ? [] : volumeNameLines.split("\n")
	}

	getPortalPropertyValue = {
		String propertyKey, String propertiesFileName = null ->

		String includeAndOverrideValue = null

		if (propertiesFileName == null) {
			includeAndOverrideValue = getPortalPropertyValue(propertyKey, "portal-setup-wizard.properties")

			if (includeAndOverrideValue == null) {
				includeAndOverrideValue = getPortalPropertyValue(propertyKey, "portal-ext.properties")
			}

			if (includeAndOverrideValue == null) {
				includeAndOverrideValue = getPortalPropertyValue(propertyKey, "portal-bundle.properties")
			}

			return includeAndOverrideValue
		}

		File propertiesFile = file("configs/local/${propertiesFileName}")

		if (!propertiesFile.exists()) {
			propertiesFile = file("configs/common/${propertiesFileName}")
		}

		if (!propertiesFile.exists()) {
			return null
		}

		propertiesFile.eachLine {
			String line ->

			line = line.trim()

			if (line.startsWith("include-and-override=")) {
				String includeAndOverrideFileName = line.split("=")[1]

				String newIncludeAndOverrideValue = getPortalPropertyValue(propertyKey, includeAndOverrideFileName)

				if (newIncludeAndOverrideValue != null) {
					includeAndOverrideValue = newIncludeAndOverrideValue
				}
			}
		}

		if (includeAndOverrideValue != null) {
			return includeAndOverrideValue
		}

		propertiesFile.withInputStream {
			BufferedInputStream inputStream ->

			Properties properties = new Properties()

			properties.load(inputStream)

			return properties.getProperty(propertyKey)
		}
	}

	toResultRows = {
		List<String> results, String lineSplitPattern ->

		results = new ArrayList<String>(results)

		String[] columnHeaders = results.pop().split(lineSplitPattern)

		return results.collect {
			String result ->

			result.trim().split(lineSplitPattern)
		}.collect {
			String[] row ->

			return [columnHeaders, row].transpose().collectEntries()
		}.collect {
			Map<String, String> resultRow ->

			Map<String, String> caseInsensitiveResultRow = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER)

			caseInsensitiveResultRow.putAll(resultRow)

			return caseInsensitiveResultRow
		}
	}

	updateGradleLocalProperties = {
		Map<String, String> newProperties ->

		File gradleLocalPropertiesFile = file("gradle-local.properties")

		List<String> seenProperties = []
		List<String> gradleLocalPropertiesLines = []

		if (gradleLocalPropertiesFile.exists()) {
			gradleLocalPropertiesLines = gradleLocalPropertiesFile.readLines().collect {
				String line ->

				int pos = line.indexOf('=')

				if (pos == -1) {
					return line
				}

				String key = line.substring(0, pos)

				if (newProperties.containsKey(key)) {
					seenProperties.add(key)
					return "${key}=${newProperties[key]}"
				}

				return line
			}
		}

		gradleLocalPropertiesFile.withOutputStream {
			BufferedOutputStream outputStream ->

			gradleLocalPropertiesLines.each {
				String line ->

				outputStream << line << "\n"
			}

			newProperties.each {
				Map.Entry<String, String> entry ->

				if (!seenProperties.contains(entry.key)) {
					outputStream << entry.key << "=" << entry.value << "\n"
				}
			}
		}
	}

	waitForCommand = {
		String command, File cwd = null ->

		ByteArrayOutputStream stdout = new ByteArrayOutputStream()

		ExecResult execResult = project.exec {
			commandLine "bash", "-c", command
			ignoreExitValue true
			standardOutput stdout

			if (cwd != null) {
				workingDir cwd
			}
		}

		execResult.assertNormalExitValue()

		return stdout.toString().trim()
	}

	waitForContainer = {
		String serviceName, String containerName ->

		String serviceStatus = waitForCommand("docker compose ps ${serviceName} --format=json").trim()

		if (serviceStatus.length() > 0) {
			JsonSlurper jsonSlurper = new JsonSlurper()

			String health = jsonSlurper.parseText(serviceStatus)["Health"]

			if ((health != null) && health.equals("healthy")) {
				return
			}
		}
		else {
			println "Starting service ${serviceName}"
			waitForCommand("docker compose up -d ${serviceName}")
		}

		String status = ""

		while (!status.equals("\"healthy\"")) {
			if (status != null) {
				Thread.sleep(10000)
			}

			println "Waiting for service ${serviceName}"

			String logs = waitForCommand("docker compose logs ${serviceName} --since=10s")

			if (logs.length() > 0) {
				println logs
			}

			status = waitForCommand("docker inspect --format='{{json .State.Health.Status}}' ${containerName}").trim()
		}
	}
}

tasks.register("testFixProductVersion") {
	doLast {
		[
			["dxp-7.4.u36", "dxp-7.4.u36"],
			["dxp-7.4.u36-lts", "dxp-7.4.u36"],
			["dxp-2024.q1.1", "dxp-2024.q1.1"],
			["dxp-2024.q1.1-lts", "dxp-2024.q1.1"],
			["dxp-2025.q1.1", "dxp-2025.q1.1-lts"],
			["dxp-2025.q1.1-lts", "dxp-2025.q1.1-lts"],
			["dxp-2025.q2.1", "dxp-2025.q2.1"],
			["dxp-2025.q2.1-lts", "dxp-2025.q2.1"],
		].each {
			String[] keyValuePair ->

			String input = keyValuePair[0]
			String expected = keyValuePair[1]

			assert expected == Util.fixReleaseKey(input)
		}
	}
}

tasks.register("runUtilTests") {
	dependsOn ":testFixProductVersion"
}