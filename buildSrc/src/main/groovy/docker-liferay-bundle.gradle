import com.liferay.docker.workspace.environments.Util

import de.undercouch.gradle.tasks.download.Download

import groovy.io.FileType

import groovy.xml.XmlSlurper
import groovy.xml.slurpersupport.GPathResult

import java.nio.file.Path
import java.nio.file.Paths

project.plugins.apply "docker-common"

configurations {
	db2
}

dependencies {
	db2 group: "com.ibm.db2.jcc", name: "db2jcc", version: "db2jcc4"
}

Closure<Boolean> isValidLicenseFile = {
	File licenseFile ->

	String licenseText = licenseFile.text

	if (!licenseText.contains("<license>")) {
		return false
	}

	String invalidLicenseReason = null

	XmlSlurper xmlSlurper = new XmlSlurper()

	GPathResult gPathResult = xmlSlurper.parse(licenseFile)

	if (config.useClustering) {
		String licenseType = gPathResult["license-type"].text()

		if (["developer", "limited", "trial"].contains(licenseType)) {
			invalidLicenseReason = "Clustering is enabled, but ${licenseType} license file ${licenseFile.absolutePath} cannot be used in a clustered environment"
		}
	}

	String expirationDateText = gPathResult["expiration-date"].text()

	if (new Date(expirationDateText).before(new Date())) {
		invalidLicenseReason = "License file ${licenseFile.absolutePath} expired on ${expirationDateText}"
	}

	if (invalidLicenseReason == null) {
		return true
	}

	println invalidLicenseReason

	licenseFile.delete()

	return false
}

Closure<String> getLatestImageName = {
	List<String> dxpImageNames ->

	if (dxpImageNames.isEmpty()) {
		return null
	}

	String latestQuarterlyRelease = dxpImageNames.collect {
		String dxpImageName ->

		dxpImageName.substring(0, dxpImageName.indexOf(".q") + 3)
	}.sort().last()

	String latestQuarterlyReleaseTag = dxpImageNames.findAll {
		String dxpImageName ->

		dxpImageName.startsWith(latestQuarterlyRelease)
	}.sort {
		String a, String b ->

		int aPatch = Integer.parseInt(a.substring(a.indexOf(".q") + 4).split("-")[0])
		int bPatch = Integer.parseInt(b.substring(b.indexOf(".q") + 4).split("-")[0])

		return aPatch - bPatch
	}.last()

	return "liferay/dxp:" + latestQuarterlyReleaseTag
}

Closure<String> getLatestImageNameLocal = {
	String imageName ->

	if ((imageName == null) || !(imageName.contains(".q") || imageName.contains("latest"))) {
		return null
	}

	List<String> dxpImageNames = waitForCommand("docker image ls ${imageName} --format='{{ .Tag }}'").readLines()

	if (dxpImageNames.isEmpty()) {
		dxpImageNames = waitForCommand("docker image ls ${imageName}-* --format='{{ .Tag }}'").readLines()
	}

	return getLatestImageName(dxpImageNames)
}

Closure<FileCollection> copyLiferayLicenseFromDXPImage = {
	String imageName, boolean pullImage = false ->

	if (config.useClustering || (imageName == null) || !(imageName.contains(".q") || imageName.contains("latest"))) {
		return null
	}

	String latestImageName = getLatestImageNameLocal(imageName)

	if (latestImageName == null) {
		if (!pullImage) {
			return null
		}

		println "Docker image ${imageName} is not available, retrieving via docker pull (this may take awhile)"

		waitForCommand("docker pull ${imageName}")

		latestImageName = getLatestImageNameLocal(imageName)

		if (latestImageName == null) {
			return null
		}
	}

	String temporaryContainerName = "${config.namespace}-license-check"
	String temporaryVolumeName = "${config.namespace}-license"

	println "Attempting to copy trial license from ${latestImageName}"

	waitForCommand("docker create --name=${temporaryContainerName} --volume=${temporaryVolumeName}:/opt/liferay/deploy ${latestImageName}")
	waitForCommand("docker run --rm -v ${temporaryVolumeName}:/source -v ./configs/common/osgi/modules/:/target alpine sh -c 'cp /source/trial-*.xml /target/'")
	waitForCommand("docker rm ${temporaryContainerName}")
	waitForCommand("docker volume rm ${config.namespace}-license")

	return project.fileTree("configs") {
		include "**/osgi/modules/*.xml"
	}.filter {
		isValidLicenseFile(it)
	}
}

tasks.register("checkForLiferayLicense") {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}
	onlyIf("running Liferay DXP") {
		config.dockerImageLiferayDXP
	}

	doFirst {
		FileCollection licenseXmlFileCollection = project.fileTree("configs") {
			include "**/osgi/modules/*.xml"
		}.filter {
			isValidLicenseFile(it)
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			licenseXmlFileCollection = copyLiferayLicenseFromDXPImage(project.gradle.liferayWorkspace.dockerImageLiferay)
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			licenseXmlFileCollection = copyLiferayLicenseFromDXPImage("liferay/dxp:*.q*")
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			licenseXmlFileCollection = copyLiferayLicenseFromDXPImage("liferay/dxp:latest")
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			licenseXmlFileCollection = copyLiferayLicenseFromDXPImage(project.gradle.liferayWorkspace.dockerImageLiferay, true)
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			licenseXmlFileCollection = copyLiferayLicenseFromDXPImage("liferay/dxp:latest", true)
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			if (config.useClustering) {
				throw new GradleException("Please add a non-expired license that allows for clustering to configs/common/osgi/modules/")
			}

			throw new GradleException("Please add a non-expired license to configs/common/osgi/modules/")
		}
	}
}

tasks.register("importDocumentLibrary") {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}
	onlyIf("using an external document library") {
		config.useExternalDocumentLibrary
	}

	File documentLibraryDirectory = new File(config.documentLibraryDirectory)

	documentLibraryDirectory.eachFileRecurse (FileType.FILES) {
		file -> {
			String composerDocLibFilePath = file.toString().replaceAll(config.documentLibraryDirectory, project.file("configs/common/data/document_library").toString())

			mkdir composerDocLibFilePath.split("/").init().join("/")

			File composerDocLibFile = new File(composerDocLibFilePath)

			composerDocLibFile.createNewFile()
		}
	}
}

tasks.register("prepareDB2JDBCDriver", Copy) {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}
	onlyIf("using the DB2 database") {
		config.useDatabaseDB2
	}

	from configurations.db2
	into "configs/common/tomcat/webapps/ROOT/WEB-INF/shielded-container-lib"
}

tasks.register("validateHotfixURLs") {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}
	onlyIf("specifying a workspace product version for Liferay 7.4 or later") {
		config.product != null && config.product.startsWith("dxp-") &&
		(config.product.startsWith("dxp-7.4-") || config.product.contains(".q"))
	}

	doFirst {
		String liferayVersion = config.product.substring(4)

		if (liferayVersion.startsWith("7.4-")) {
			liferayVersion = "7.4.13-${liferayVersion.substring(4)}"
		}

		String mismatchedHotfixURL = config.hotfixURLs.find {
			String hotfixURL ->

			!hotfixURL.contains("/${liferayVersion}/")
		}

		if (mismatchedHotfixURL != null) {
			throw new GradleException("Hotfix ${mismatchedHotfixURL} does not match Liferay workspace product version ${config.product}")
		}
	}
}

tasks.register("deleteStaleHotfixes") {
	doFirst {
		Set<String> hotfixNames = config.hotfixURLs.collect {
			Path path = Paths.get(new URI(it).path)
			return path.getName(path.nameCount - 1).toString()
		}.toSet()

		if (hotfixNames.isEmpty()) {
			hotfixNames = project.fileTree("configs") {
				include "**/patching/liferay*hotfix*.zip"
			}.collect {
				File hotfixFile ->

				hotfixFile.name
			}.toSet()
		}

		project.fileTree(".") {
			include "build/docker/configs/**/patching/liferay*hotfix*.zip"
			include "configs/**/patching/liferay*hotfix*.zip"
		}.filter {
			File hotfixFile ->

			!hotfixNames.contains(hotfixFile.name)
		}.each {
			File hotfixFile ->

			println "Deleting stale hotfix ${hotfixFile.absolutePath}"
			hotfixFile.delete()
		}
	}
}

tasks.register("prepareHotfixes", Download) {
	onlyIf("there are hotfix URLs") {
		!config.hotfixURLs.isEmpty()
	}
	onlyIf("using the Liferay service") {
		config.useLiferay
	}

	dependsOn validateHotfixURLs
	finalizedBy deleteStaleHotfixes

	dest project.layout.dir(project.provider {project.file("configs/common/patching")})

	overwrite false

	src config.hotfixURLs
}

tasks.register("fixWorkspaceProduct") {
	onlyIf("product is set") {
		config.product != null
	}

	doLast {
		config.product = Util.fixReleaseKey(config.product)

		if (!config.product.equals(project.gradle.liferayWorkspace.product)) {
			project.updateGradleLocalProperties([
				"liferay.workspace.product": config.product
			])

			project.gradle.liferayWorkspace.product = config.product
		}
	}
}

verifyProduct.dependsOn fixWorkspaceProduct

tasks.register("listAdminUsers") {
	onlyIf("using an external database") {
		config.useDatabase
	}

	Closure<Void> listAdminUsersForCompany = {
		String companyId, String hostname, String webId, String schema ->

		String tcp8080Port = waitForCommand("docker compose ps liferay --format '{{range .Publishers}}{{if and (eq .URL \"0.0.0.0\") (eq .TargetPort 8080)}}{{.PublishedPort}}{{end}}{{end}}'")

		List results = executeSQLQuery("select screenName, emailAddress from User_ where companyId = ${companyId} and userId in (select userId from Users_Roles where roleId in (select roleId from Role_ where name = 'Administrator'))", schema)

		println "\nhttp://${hostname}:${tcp8080Port}/c/portal/login"
		println "http://${hostname}:${tcp8080Port}/?p_p_id=com_liferay_login_web_portlet_LoginPortlet&p_p_lifecycle=0&p_p_state=exclusive&p_p_mode=view&_com_liferay_login_web_portlet_LoginPortlet_mvcRenderCommandName=%2Flogin%2Flogin&saveLastPath=false"
		println getDatabaseAccessCommand(schema)

		if (results.isEmpty()) {
			println "Unable to detect users explicitly granted the Administrator role"
		}
		else {
			println "Detected the following users explicitly granted the Administrator role"

			results.each {
				Map<String, String> resultRow ->

				println " - ${resultRow["screenName"]} (${resultRow["emailAddress"]})"
			}
		}
	}

	doFirst {
		forEachCompanyId listAdminUsersForCompany
	}
}

tasks.register("exportLiferayLogs", Exec) {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}

	executable project.file("scripts/export_liferay_logs.sh")
}

tasks.register("printBundleInfo", Exec) {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}

	environment("LIFERAY_PRODUCT", config.dockerImageLiferayDXP ? "dxp" : "portal")
	environment("LIFERAY_VERSION", gradle.liferayWorkspace.targetPlatformVersion)

	executable project.file("scripts/print_bundle_info.sh")
}

tasks.register("downloadYourKitAgentZip", Download) {
	onlyIf("using YourKit") {
		config.yourKitEnabled
	}

	dest layout.buildDirectory.file("downloadYourKitAgentZip/YourKit.zip")

	overwrite true

	src config.yourKitUrl
}

tasks.register("prepareYourKitAgent", Copy) {
	onlyIf("using YourKit") {
		config.yourKitEnabled
	}

	dependsOn ":downloadYourKitAgentZip"

	eachFile {
		File file ->

		file.relativePath = RelativePath.parse(true, file.name)
	}

	from zipTree(downloadYourKitAgentZip.dest)

	if (config.isARM) {
		include "**/linux-arm-64/libyjpagent.so"
	}
	else {
		include "**/linux-x86-64/libyjpagent.so"
	}

	includeEmptyDirs false
	into "configs/common/yourkit"
}