import com.liferay.docker.workspace.environments.Util

import de.undercouch.gradle.tasks.download.Download

import groovy.xml.XmlSlurper
import groovy.xml.slurpersupport.GPathResult

import java.nio.file.Path
import java.nio.file.Paths

project.plugins.apply "docker-common"

Closure<Boolean> isValidLicenseFile = {
	File licenseFile ->

	String licenseText = licenseFile.text

	if (!licenseText.contains("<license>")) {
		return false
	}

	XmlSlurper xmlSlurper = new XmlSlurper()

	GPathResult gPathResult = xmlSlurper.parse(licenseFile)
	String expirationDateText = gPathResult["expiration-date"].text()

	if (new Date(expirationDateText).after(new Date())) {
		return true
	}

	println "License file ${licenseFile.absolutePath} expired on ${expirationDateText}"

	licenseFile.delete()

	return false
}

Closure<FileCollection> copyLiferayLicenseFromDXPImage = {
	String imageName ->

	if ((imageName == null) || !imageName.contains(".q")) {
		return null
	}

	String temporaryContainerName = "${config.namespace.toLowerCase()}-license-check"
	String temporaryVolumeName = "${config.namespace.toLowerCase()}-license"

	waitForCommand("docker create --name=${temporaryContainerName} --volume=${temporaryVolumeName}:/opt/liferay/deploy ${imageName}")
	waitForCommand("docker run --rm -v ${temporaryVolumeName}:/source -v ./configs/common/osgi/modules/:/target alpine sh -c 'cp /source/trial-*.xml /target/'")
	waitForCommand("docker rm ${temporaryContainerName}")
	waitForCommand("docker volume rm ${config.namespace.toLowerCase()}-license")

	return project.fileTree("configs") {
		include "**/osgi/modules/*.xml"
	}.filter {
		isValidLicenseFile(it)
	}
}

tasks.register("checkForLiferayLicense") {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}
	onlyIf("running Liferay DXP") {
		config.dockerImageLiferayDXP
	}

	doFirst {
		FileCollection licenseXmlFileCollection = project.fileTree("configs") {
			include "**/osgi/modules/*.xml"
		}.filter {
			isValidLicenseFile(it)
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			licenseXmlFileCollection = copyLiferayLicenseFromDXPImage(project.gradle.liferayWorkspace.dockerImageLiferay)
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			List<String> dxpImageTagNames = waitForCommand("docker image ls liferay/dxp:*.q* --format='{{ .Tag }}'").split("\n").collect {
				it.trim()
			}

			String latestQuarterlyRelease = dxpImageTagNames.collect {
				it.substring(0, it.indexOf(".q") + 3)
			}.sort().last()

			String latestQuarterlyReleaseTag = dxpImageTagNames.findAll {
				it.startsWith(latestQuarterlyRelease)
			}.sort {
				String a, String b ->

				return Integer.parseInt(a.substring(it.indexOf(".q" + 4)).split("-")[0]) - Integer.parseInt(b.substring(it.indexOf(".q" + 4)).split("-")[0])
			}.last()

			licenseXmlFileCollection = copyLiferayLicenseFromDXPImage("liferay/dxp:" + latestQuarterlyReleaseTag)
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			throw new GradleException("Please add a non-expired license to configs/common/osgi/modules/")
		}
	}
}

tasks.register("validateHotfixURLs") {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}
	onlyIf("specifying a workspace product version for Liferay 7.4 or later") {
		config.product != null && config.product.startsWith("dxp-") &&
		(config.product.startsWith("dxp-7.4-") || config.product.contains(".q"))
	}

	doFirst {
		String liferayVersion = config.product.substring(4)

		if (liferayVersion.startsWith("7.4-")) {
			liferayVersion = "7.4.13-${liferayVersion.substring(4)}"
		}

		String mismatchedHotfixURL = config.hotfixURLs.find {
			!it.contains("/${liferayVersion}/")
		}

		if (mismatchedHotfixURL != null) {
			throw new GradleException("Hotfix ${mismatchedHotfixURL} does not match Liferay workspace product version ${config.product}")
		}
	}
}

tasks.register("deleteStaleHotfixes") {
	doFirst {
		Set<String> hotfixNames = config.hotfixURLs.collect {
			Path path = Paths.get(new URI(it).path)
			return path.getName(path.nameCount - 1).toString()
		}.toSet()

		if (hotfixNames.isEmpty()) {
			hotfixNames = project.fileTree("configs") {
				include "**/patching/liferay*hotfix*.zip"
			}.collect {
				it.name
			}.toSet()
		}

		project.fileTree(".") {
			include "build/docker/configs/**/patching/liferay*hotfix*.zip"
			include "configs/**/patching/liferay*hotfix*.zip"
		}.filter {
			!hotfixNames.contains(it.name)
		}.each {
			println "Deleting stale hotfix ${it.absolutePath}"
			it.delete()
		}
	}
}

tasks.register("prepareHotfixes", Download) {
	onlyIf("there are hotfix URLs") {
		!config.hotfixURLs.isEmpty()
	}
	onlyIf("using the Liferay service") {
		config.useLiferay
	}

	dependsOn validateHotfixURLs
	finalizedBy deleteStaleHotfixes

	dest project.layout.dir(project.provider {project.file("configs/common/patching")})

	overwrite false

	src config.hotfixURLs
}

tasks.register("fixWorkspaceProduct") {
	onlyIf("product is set") {
		config.product != null
	}

	doLast {
		config.product = Util.fixReleaseKey(config.product)

		if (!config.product.equals(project.gradle.liferayWorkspace.product)) {
			project.updateGradleLocalProperties([
				"liferay.workspace.product": config.product
			])

			project.gradle.liferayWorkspace.product = config.product
		}
	}
}

verifyProduct.dependsOn fixWorkspaceProduct

tasks.register("listAdminUsers") {
	onlyIf("using an external database") {
		config.useDatabase
	}

	Closure<Void> listAdminUsersForCompany = {
		String companyId, String hostname, String webId, String schema ->

		List results = executeSQLQuery("select screenName, emailAddress from User_ where companyId = ${companyId} and userId in (select userId from Users_Roles where roleId in (select roleId from Role_ where name = 'Administrator'))", schema)

		println "\nhttp://${hostname}:8080/c/portal/login"
		println "http://${hostname}:8080/?p_p_id=com_liferay_login_web_portlet_LoginPortlet&p_p_lifecycle=0&p_p_state=exclusive&p_p_mode=view&_com_liferay_login_web_portlet_LoginPortlet_mvcRenderCommandName=%2Flogin%2Flogin&saveLastPath=false"
		println getDatabaseAccessCommand(schema)

		if (results.isEmpty()) {
			println "Unable to detect users explicitly granted the Administrator role"
		}
		else {
			println "Detected the following users explicitly granted the Administrator role"

			results.each {
				println " - ${it["screenName"]} (${it["emailAddress"]})"
			}
		}
	}

	doFirst {
		forEachCompanyId listAdminUsersForCompany
	}
}

tasks.register("printBundleInfo", Exec) {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}

	executable project.file("scripts/print_bundle_info.sh")
}

tasks.register("downloadYourKitAgentZip", Download) {
	onlyIf("using YourKit") {
		config.yourKitEnabled
	}

	dest layout.buildDirectory.file("downloadYourKitAgentZip/YourKit.zip")

	overwrite true

	src config.yourKitUrl
}

tasks.register("prepareYourKitAgent", Copy) {
	onlyIf("using YourKit") {
		config.yourKitEnabled
	}

	dependsOn ":downloadYourKitAgentZip"

	eachFile {
		it.relativePath = RelativePath.parse(true, it.name)
	}

	from zipTree(downloadYourKitAgentZip.dest)

	if (config.isARM) {
		include "**/linux-arm-64/libyjpagent.so"
	}
	else {
		include "**/linux-x86-64/libyjpagent.so"
	}

	includeEmptyDirs false
	into "configs/common/yourkit"
}